use std::path::PathBuf;

use dofigen_lib::*;
use pretty_assertions_sorted::assert_eq_sorted;

#[test]
#[cfg(feature = "permissive")]
fn yaml_to_dockerfile() {
    let yaml = r#"
        image: scratch
        builders:
        - name: builder
          from: ekidd/rust-musl-builder
          user: rust
          add: "."
          run:
          - ls -al
          - cargo build --release
          cache: /usr/local/cargo/registry
        - name: watchdog
          from: ghcr.io/openfaas/of-watchdog:0.9.6
        env:
          fprocess: /app
        artifacts:
        - builder: builder
          source: /home/rust/src/target/x86_64-unknown-linux-musl/release/template-rust
          target: /app
        - builder: builder
          source: /fwatchdog
          target: /fwatchdog
        expose: 8080
        healthcheck:
          interval: 3s
          cmd: "[ -e /tmp/.lock ] || exit 1"
        cmd: "/fwatchdog"
        ignores:
        - target
        - test
        "#;

    let image: Image = from(yaml.into()).map_err(Error::from).unwrap();
    let dockerfile: String = generate_dockerfile(&image).unwrap();

    assert_eq_sorted!(
        dockerfile,
        r#"# This file is generated by Dofigen v0.0.0
# See https://github.com/lenra-io/dofigen

# syntax=docker/dockerfile:1.7

# builder
FROM ekidd/rust-musl-builder AS builder
COPY \
    --chown=rust \
    --link \
    "." "./"
USER rust
RUN \
    --mount=type=cache,target=/usr/local/cargo/registry,sharing=locked \
    ls -al && \
    cargo build --release

# watchdog
FROM ghcr.io/openfaas/of-watchdog:0.9.6 AS watchdog

# runtime
FROM scratch AS runtime
ENV fprocess="/app"
COPY \
    --from=builder \
    --chown=1000:1000 \
    --link \
    "/home/rust/src/target/x86_64-unknown-linux-musl/release/template-rust" "/app"
COPY \
    --from=builder \
    --chown=1000:1000 \
    --link \
    "/fwatchdog" "/fwatchdog"
USER 1000:1000
EXPOSE 8080
HEALTHCHECK \
    --interval=3s \
    CMD [ -e /tmp/.lock ] || exit 1
CMD ["/fwatchdog"]
"#
    );

    let dockerignore: String = generate_dockerignore(&image);

    assert_eq_sorted!(dockerignore, "# This file is generated by Dofigen v0.0.0\n# See https://github.com/lenra-io/dofigen\n\ntarget\ntest\n");
}

#[test]
#[cfg(feature = "permissive")]
fn using_dockerfile_overlap_aliases() {
    let yaml = r#"
builders:
- name: builder
  image: ekidd/rust-musl-builder
  adds:
  - "*"
  script:
  - cargo build --release
artifacts:
- builder: builder
  source: /home/rust/src/target/x86_64-unknown-linux-musl/release/template-rust
  destination: /app
"#;
    let image: Image = from(yaml.into()).unwrap();
    assert_eq_sorted!(
        image,
        Image {
            builders: vec![Stage {
                name: Some(String::from("builder")),
                from: ImageName {
                    path: String::from("ekidd/rust-musl-builder"),
                    ..Default::default()
                }
                .into(),
                copy: vec![CopyResource::Copy(
                    Copy {
                        paths: vec![String::from("*")].into(),
                        ..Default::default()
                    }
                    .into()
                )]
                .into(),
                run: vec![String::from("cargo build --release")].into(),
                ..Default::default()
            }]
            .into(),
            stage: Stage {
                artifacts: vec![Artifact {
                    builder: String::from("builder"),
                    source: String::from(
                        "/home/rust/src/target/x86_64-unknown-linux-musl/release/template-rust"
                    ),
                    target: String::from("/app"),
                    ..Default::default()
                }]
                .into(),
                ..Default::default()
            },
            ..Default::default()
        }
    );
}

#[test]
#[cfg(feature = "permissive")]
fn multiline_run_field() {
    let yaml = r#"
from: scratch
run:
  - |
    if [ "test" = "test" ]; then
      echo "Test"
    fi
"#;
    let image: Image = from(yaml.into()).unwrap();
    let dockerfile: String = generate_dockerfile(&image).unwrap();

    assert_eq_sorted!(
        dockerfile,
        r#"# This file is generated by Dofigen v0.0.0
# See https://github.com/lenra-io/dofigen

# syntax=docker/dockerfile:1.7

# runtime
FROM scratch AS runtime
USER 1000:1000
RUN \
    if [ "test" = "test" ]; then \
      echo "Test" \
    fi
"#
    );
}

#[ignore]
// Not managed yet by serde: https://serde.rs/field-attrs.html#flatten
#[test]
#[cfg(feature = "permissive")]
fn combine_field_and_aliases() {
    let yaml = r#"
image: scratch
from: alpine
"#;
    let result = from(yaml.into());
    assert!(
        result.is_err(),
        "The parsing must fail since from and image are not compatible",
    );
}

#[test]
#[cfg(feature = "permissive")]
fn fail_on_unknow_field() {
    let yaml = r#"
from: alpine
test: Fake value
"#;
    let result = from(yaml.into());
    assert!(
        result.is_err(),
        "The parsing must fail since 'test' is not a valid field"
    );

    // Check the error message
    let error = result.unwrap_err();
    let expected =
        "Error while deserializing the document at line 2, column 1: unknown field `test`";
    assert_eq_sorted!(
        &error.to_string().as_str()[..expected.len()],
        expected,
        "Wrong error message"
    );
}

#[test]
#[cfg(feature = "permissive")]
fn manage_plural_aliases() -> Result<()> {
    let yaml = r#"
from: scratch
builders:
- name: builder
  from: ekidd/rust-musl-builder
  user: rust
  adds: 
  - "."
  run:
  - cargo build --release
  caches:
  - /usr/local/cargo/registry
- name: watchdog
  from: ghcr.io/openfaas/of-watchdog:0.9.6
envs:
  fprocess: /app
artifacts:
- builder: builder
  source: /home/rust/src/target/x86_64-unknown-linux-musl/release/template-rust
  target: /app
- builder: builder
  source: /fwatchdog
  target: /fwatchdog
ports:
- 8080
ignore:
- target
- test
"#;

    from(yaml.into())?;
    Ok(())
}

#[test]
#[cfg(feature = "permissive")]
fn artifact_copy_custom_user() {
    let yaml = r#"
        builders:
        - name: builder
          from: ekidd/rust-musl-builder
          user: rust
          add: "."
          run: cargo build --release
          cache: /usr/local/cargo/registry
        user: 1001
        artifacts:
        - builder: builder
          source: /home/rust/src/target/x86_64-unknown-linux-musl/release/template-rust
          target: /app
        run: echo "coucou"
        cache: /tmp
        "#;

    let image: Image = from(yaml.into()).unwrap();
    let dockerfile: String = generate_dockerfile(&image).unwrap();

    assert_eq_sorted!(
        dockerfile,
        r#"# This file is generated by Dofigen v0.0.0
# See https://github.com/lenra-io/dofigen

# syntax=docker/dockerfile:1.7

# builder
FROM ekidd/rust-musl-builder AS builder
COPY \
    --chown=rust \
    --link \
    "." "./"
USER rust
RUN \
    --mount=type=cache,target=/usr/local/cargo/registry,sharing=locked \
    cargo build --release

# runtime
FROM scratch AS runtime
COPY \
    --from=builder \
    --chown=1001 \
    --link \
    "/home/rust/src/target/x86_64-unknown-linux-musl/release/template-rust" "/app"
USER 1001
RUN \
    --mount=type=cache,target=/tmp,sharing=locked,uid=1001 \
    echo "coucou"
"#
    );
}

#[cfg(feature = "permissive")]
#[test]
fn test_cases() {
    // Get all the files in the tests/cases directory
    let paths: Vec<PathBuf> = std::fs::read_dir("tests/cases")
        .unwrap()
        .map(|entry| entry.unwrap().path())
        .collect();

    let path_ref: Vec<&PathBuf> = paths.iter().collect();

    // Get the YAML results by filtering the files ending with .result.yml in a map with the basename as key
    let (yaml_results, path_ref) = filter_to_map(path_ref, ".result.yml");

    // Get the Dockerfile results by filtering the files ending with .result.Dockerfile in a map with the basename as key
    let (dockerfile_results, path_ref) = filter_to_map(path_ref, ".result.Dockerfile");

    // Iterate over remaining files and generate the effective YAML and Dockerfile to compare with the expected results
    for path in path_ref {
        let mut basename = path.to_str().unwrap().to_string();
        basename.truncate(basename.len() - path.extension().unwrap().to_str().unwrap().len() - 1);

        println!("Processing {}", basename);

        let image: Image = from_file_path(path).unwrap();

        if let Some(content) = yaml_results.get(basename.as_str()) {
            println!("Compare with YAML result");
            let yaml = serde_yaml::to_string(&image).unwrap();
            assert_eq_sorted!(&yaml, content);
        }

        if let Some(content) = dockerfile_results.get(basename.as_str()) {
            println!("Compare with Dockerfile result");
            let dockerfile = generate_dockerfile(&image).unwrap();
            assert_eq_sorted!(&dockerfile, content);
        }
    }
}

fn filter_to_map<'a>(
    files: Vec<&'a PathBuf>,
    filter: &str,
) -> (std::collections::HashMap<String, String>, Vec<&'a PathBuf>) {
    let (results, files): (_, Vec<_>) = files
        .into_iter()
        .partition(|path| path.to_str().unwrap().ends_with(filter));

    let results = results
        .iter()
        .filter_map(|path| {
            let mut basename = path.to_str().unwrap().to_string();
            basename.truncate(basename.len() - filter.len());
            let content = std::fs::read_to_string(path).unwrap();
            Some((basename, content))
        })
        .collect::<std::collections::HashMap<String, String>>();

    (results, files)
}

#[cfg(feature = "permissive")]
#[test]
fn test_load_url() {
    use httptest::{matchers::*, responders::*, Expectation, Server};
    use url::Url;

    let test_case_dir = PathBuf::from("tests/cases/");
    let server = Server::run();
    let files = vec!["springboot-maven.base.yml", "springboot-maven.override.yml"];
    for file in files {
        server.expect(
            Expectation::matching(request::method_path("GET", format!("/{}", file))).respond_with(
                status_code(200).body(
                    std::fs::read_to_string(test_case_dir.join(file)).unwrap(),
                ),
            ),
        );
    }

    let url = server.url("/springboot-maven.override.yml");

    println!("URL: {}", url);

    let url = url.to_string();
    let url: Url = url.parse().unwrap();

    let image: Image = from_resource(Resource::Url(url)).unwrap();

    let yaml = serde_yaml::to_string(&image).unwrap();
    assert_eq_sorted!(yaml, std::fs::read_to_string(test_case_dir.join("springboot-maven.override.result.yml")).unwrap());

    let dockerfile = generate_dockerfile(&image).unwrap();
    assert_eq_sorted!(dockerfile, std::fs::read_to_string(test_case_dir.join("springboot-maven.override.result.Dockerfile")).unwrap());
}
