//! # dofigen_lib
//!
//! `dofigen_lib` help creating Dockerfile with a simplified structure and made to cache the build with Buildkit.
//! You also can parse the structure from YAML or JSON.
//!
//! ```
//! use dofigen_lib::*;
//! use pretty_assertions_sorted::assert_eq_sorted;
//!
//! let mut context = DofigenContext::new();
//!
//! let dofigen = context.parse_from_string(r#"
//! fromImage:
//!   path: ubuntu
//! "#).unwrap();
//!
//! let dockerfile = generate_dockerfile(&dofigen).unwrap();
//! ```

mod context;
mod deserialize;
mod dockerfile_struct;
mod dofigen_struct;
mod errors;
mod extend;
#[cfg(feature = "permissive")]
mod from_str;
mod generator;
#[cfg(feature = "json_schema")]
mod json_schema;
mod linter;
pub mod lock;
#[cfg(feature = "json_schema")]
use schemars::*;
pub use {
    context::*, deserialize::*, dofigen_struct::*, errors::*, extend::*,
    generator::GenerationContext, linter::*,
};

#[cfg(all(feature = "strict", feature = "permissive"))]
compile_error!("You can't enable both 'strict' and 'permissive' features at the same time.");

pub(crate) const DOCKERFILE_VERSION: &str = "1.11";

const FILE_HEADER_COMMENTS: [&str; 2] = [
    concat!(
        "This file is generated by Dofigen v",
        env!("CARGO_PKG_VERSION")
    ),
    concat!("See ", env!("CARGO_PKG_REPOSITORY")),
];

/// Generates the Dockerfile content from a Dofigen struct.
///
/// # Examples
///
/// ```
/// use dofigen_lib::*;
/// use pretty_assertions_sorted::assert_eq_sorted;
///
/// let dofigen = Dofigen {
///     stage: Stage {
///         from: ImageName {
///             path: String::from("ubuntu"),
///             ..Default::default()
///         }.into(),
///         ..Default::default()
///     },
///     ..Default::default()
/// };
/// let dockerfile: String = generate_dockerfile(&dofigen).unwrap();
/// assert_eq_sorted!(
///     dockerfile,
///     "# syntax=docker/dockerfile:1.11\n# This file is generated by Dofigen v0.0.0\n# See https://github.com/lenra-io/dofigen\n\n# runtime\nFROM ubuntu AS runtime\nUSER 1000:1000\n"
/// );
/// ```
#[deprecated(
    since = "2.2.0",
    note = "Please use `GenerationContext::generate_dockerfile` from `dofigen_lib` instead"
)]
pub fn generate_dockerfile(dofigen: &Dofigen) -> Result<String> {
    GenerationContext::from(dofigen.clone()).generate_dockerfile()
}

/// Generates the .dockerignore file content from an Dofigen struct.
///
/// # Examples
///
/// ## Define the build context
///
/// ```
/// use dofigen_lib::*;
/// use pretty_assertions_sorted::assert_eq_sorted;
///
/// let dofigen = Dofigen {
///     context: vec![String::from("/src")].into(),
///     ..Default::default()
/// };
/// let dockerfile: String = generate_dockerignore(&dofigen);
/// assert_eq_sorted!(
///     dockerfile,
///     "# This file is generated by Dofigen v0.0.0\n# See https://github.com/lenra-io/dofigen\n\n**\n!/src\n"
/// );
/// ```
///
/// ## Ignore a path
///
/// ```
/// use dofigen_lib::*;
/// use pretty_assertions_sorted::assert_eq_sorted;
///
/// let dofigen = Dofigen {
///     ignore: vec![String::from("target")].into(),
///     ..Default::default()
/// };
/// let dockerfile: String = generate_dockerignore(&dofigen);
/// assert_eq_sorted!(
///     dockerfile,
///     "# This file is generated by Dofigen v0.0.0\n# See https://github.com/lenra-io/dofigen\n\ntarget\n"
/// );
/// ```
///
/// ## Define context ignoring a specific files
///
/// ```
/// use dofigen_lib::*;
/// use pretty_assertions_sorted::assert_eq_sorted;
///
/// let dofigen = Dofigen {
///     context: vec![String::from("/src")].into(),
///     ignore: vec![String::from("/src/*.test.rs")].into(),
///     ..Default::default()
/// };
/// let dockerfile: String = generate_dockerignore(&dofigen);
/// assert_eq_sorted!(
///     dockerfile,
///     "# This file is generated by Dofigen v0.0.0\n# See https://github.com/lenra-io/dofigen\n\n**\n!/src\n/src/*.test.rs\n"
/// );
/// ```
#[deprecated(
    since = "2.2.0",
    note = "Please use `GenerationContext::generate_dockerignore` from `dofigen_lib` instead"
)]
pub fn generate_dockerignore(dofigen: &Dofigen) -> String {
    GenerationContext::from(dofigen.clone())
        .generate_dockerignore()
        .unwrap()
}

/// Generates the effective Dofigen content from a Dofigen struct.
///
/// # Examples
///
/// ```
/// use dofigen_lib::*;
/// use pretty_assertions_sorted::assert_eq_sorted;
///
/// let dofigen = Dofigen {
///     stage: Stage {
///         from: ImageName {
///             path: String::from("ubuntu"),
///             ..Default::default()
///         }.into(),
///         ..Default::default()
///     },
///     ..Default::default()
/// };
/// let dofigen: String = generate_effective_content(&dofigen).unwrap();
/// assert_eq_sorted!(
///     dofigen,
///     "fromImage:\n  path: ubuntu\n"
/// );
/// ```
pub fn generate_effective_content(dofigen: &Dofigen) -> Result<String> {
    Ok(serde_yaml::to_string(&dofigen)?)
}

/// Generates the JSON schema for the Dofigen struct.
/// This is useful to validate the structure and IDE autocompletion.
#[cfg(feature = "json_schema")]
pub fn generate_json_schema() -> String {
    use schemars::{
        generate::SchemaSettings,
        transform::{AddNullable, Transform},
    };

    let settings = SchemaSettings::draft07();
    let generator = settings.into_generator();
    let mut schema = generator.into_root_schema_for::<Extend<DofigenPatch>>();
    AddNullable::default().transform(&mut schema);
    serde_json::to_string_pretty(&schema).unwrap()
}
